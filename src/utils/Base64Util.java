/**
 * Copyright(C) 2020  Luvina Software
 * Base64Util.java, Feb 10, 2020 Net
 */
package utils;

public class Base64Util {
	 /**
     * how we separate lines, e.g. \n, \r\n, \r etc.
     **/
    static String lineSeparator = System.getProperty( "line.separator");

    /**
     * max chars per line. A multiple of 4.
     **/
    private static int lineLength = 72;


    /**
     * determines how long the lines are that are generated by encode.
     * Ignored by decode.
     * @param length 0 means no newlines inserted.
     */
    public static void setLineLength(int length)
    {
        lineLength = length;
    }

    /**
     * letter of the alphabet used to encode binary values 0..63
     **/
    static final char[] valueToChar = new char[64];


    /**
     * binary value encoded by a given letter of the alphabet 0..63
     **/
    static final int[] charToValue = new int[256];



    /**
     * Marker value for chars we just ignore, e.g. \n \r high ascii
     */
    static final int IGNORE = -1;

    /**
     * Marker for = trailing pad
     */
    static final int PAD = -2;


    static
    {
        // build translate valueToChar table only once.
        // 0..25 -> 'A'..'Z'
        for ( int i=0; i<=25; i++ )
            valueToChar[i] = (char)('A'+i);
        // 26..51 -> 'a'..'z'
        for ( int i=0; i<=25; i++ )
            valueToChar[i+26] = (char)('a'+i);
        // 52..61 -> '0'..'9'
        for ( int i=0; i<=9; i++ )
            valueToChar[i+52] = (char)('0'+i);
        valueToChar[62] = '+';
        valueToChar[63] = '/';

        // build translate charToValue table only once.
        for ( int i=0; i<256; i++ )
        {
        charToValue[i] = IGNORE;  // default is to ignore
        }

        for ( int i=0; i<64; i++ )
        {
        charToValue[valueToChar[i]] = i;
        }

        charToValue['='] = PAD;
    }

    /**
     * Encode an arbitrary array of bytes as Base64 printable ASCII.
     * It will be broken into lines of 72 chars each.  The last line
     * is not
     * terminated with a line separator.
     */
    public static String encode(byte[] b)
    {
        // Each group or partial group of 3 bytes becomes four chars
        int outputLength = ((b.length + 2) / 3) * 4;

        // account for embedded newlines
        outputLength += (outputLength / lineLength) *
        lineSeparator.length();

        // must be local for recursion to work.
        StringBuffer sb = new StringBuffer( outputLength );

        // must be local for recursion to work.
        int linePos = 0;

        // first deal with even multiples of 3 bytes.
        int len = (b.length / 3) * 3;
        int leftover = b.length - len;
        for ( int i=0; i<len; i+=3 )
        {


        // Start a new line if next 4 chars won't fit on the current line
        // We don't encapsulate so that linePos and sb will work recursively
        {

            linePos += 4;
            if ( linePos > lineLength )
            {
                linePos = 0;
                if ( lineLength != 0) {sb.append(lineSeparator);}
            }
        }

        // get next three bytes in unsigned form lined up,
        // in big-endian order
        int combined = b[i+0] & 0xff;
        combined <<= 8;
        combined |= b[i+1] & 0xff;
        combined <<= 8;
        combined |= b[i+2] & 0xff;

        // break those 24 bits into a 4 groups of 6 bits,
        // working LSB to MSB.
        int c3 = combined & 0x3f;
        combined >>>= 6;
        int c2 = combined & 0x3f;
        combined >>>= 6;
        int c1 = combined & 0x3f;
        combined >>>= 6;
        int c0 = combined & 0x3f;

        // Translate into the equivalent alpha character
        // emitting them in big-endian order.
        sb.append( valueToChar[c0]);
        sb.append( valueToChar[c1]);
        sb.append( valueToChar[c2]);
        sb.append( valueToChar[c3]);
        }

        // deal with leftover bytes
        switch ( leftover )
        {
            case 0:
            default:
                // nothing to do
                break;

            case 1:
                // One leftover byte generates xx==
                // Start a new line if next 4 chars won't fit on the current line
                // We don't encapsulate so that linePos and sb will work recursively
                {

                    linePos += 4;
                    if ( linePos > lineLength )
            {
                linePos = 0;
                if ( lineLength != 0) {sb.append(lineSeparator);}
            }
                }
                // Handle this recursively with a faked complete triple.
                // Throw away last two chars and replace with ==
                sb.append(encode(new byte[] {b[len], 0, 0}
                 ).substring(0,2));
                sb.append("==");
                break;

            case 2:
                // Two leftover bytes generates xxx=
                // Start a new line if next 4 chars won't fit on the current line
                // We don't encapsulate so that linePos and sb will work recursively
                {
                    linePos += 4;
                    if ( linePos > lineLength )
            {
                linePos = 0;
                if ( lineLength != 0) {sb.append(lineSeparator);}
            }
                }
                // Handle this recursively with a faked complete triple.
                // Throw away last char and replace with =
                sb.append(encode(new byte[] {b[len], b[len+1], 0}
                 ).substring(0,3));
                sb.append("=");
                break;

        } // end switch;

        if ( outputLength != sb.length() ) System.out.println("oops");

        return sb.toString();
    }// end encode
}
